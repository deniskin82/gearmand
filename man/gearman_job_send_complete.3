.\" Man page generated from reStructuredText.
.
.TH "GEARMAN_JOB_SEND_COMPLETE" "3" "February 11, 2014" "1.1.12" "Gearmand"
.SH NAME
gearman_job_send_complete \- Gearmand Documentation, http://gearman.info/
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH SYNOPSIS
.sp
#include <libgearman/gearman.h>
.INDENT 0.0
.TP
.B gearman_job_st
.UNINDENT
.INDENT 0.0
.TP
.B void gearman_job_free(\fI\%gearman_job_st\fP\fI\ *job\fP)
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_job_send_data(\fI\%gearman_job_st\fP\fI\ *job\fP, const void\fI\ *data\fP, size_t\fI\ data_size\fP)
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_job_send_warning(\fI\%gearman_job_st\fP\fI\ *job\fP, const void\fI\ *warning\fP, size_t\fI\ warning_size\fP)
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_job_send_status(\fI\%gearman_job_st\fP\fI\ *job\fP, uint32_t\fI\ numerator\fP, uint32_t\fI\ denominator\fP)
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_job_send_complete(\fI\%gearman_job_st\fP\fI\ *job\fP, const void\fI\ *result\fP, size_t\fI\ result_size\fP)
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_job_send_exception(\fI\%gearman_job_st\fP\fI\ *job\fP, const void\fI\ *exception\fP, size_t\fI\ exception_size\fP)
.UNINDENT
.INDENT 0.0
.TP
.B gearman_return_t gearman_job_send_fail(\fI\%gearman_job_st\fP\fI\ *job\fP)
.UNINDENT
.INDENT 0.0
.TP
.B const char *gearman_job_handle(const \fI\%gearman_job_st\fP\fI\ *job\fP)
.UNINDENT
.INDENT 0.0
.TP
.B const char *gearman_job_function_name(const \fI\%gearman_job_st\fP\fI\ *job\fP)
.UNINDENT
.INDENT 0.0
.TP
.B const char *gearman_job_unique(const \fI\%gearman_job_st\fP\fI\ *job\fP)
.UNINDENT
.INDENT 0.0
.TP
.B const void *gearman_job_workload(const \fI\%gearman_job_st\fP\fI\ *job\fP)
.UNINDENT
.INDENT 0.0
.TP
.B size_t gearman_job_workload_size(const \fI\%gearman_job_st\fP\fI\ *job\fP)
.UNINDENT
.INDENT 0.0
.TP
.B void *gearman_job_take_workload(\fI\%gearman_job_st\fP\fI\ *job\fP, size_t\fI\ *data_size\fP)
.UNINDENT
.INDENT 0.0
.TP
.B gearman_client_st *gearman_job_use_client(\fI\%gearman_job_st\fP\fI\ *job\fP)
.UNINDENT
.sp
Link with \-lgearman
.SH DESCRIPTION
.sp
\fI\%gearman_job_st\fP are passed to worker functions to represent jobs that are being run by \fBgearman_worker_work()\fP\&.
.sp
\fI\%gearman_job_free()\fP is used to free a job. This only needs to be
done if a task was created with a preallocated structure.
.sp
\fI\%gearman_job_handle()\fP returns the job handle(see \fBgearman_job_handle_t\fP for more information).
.sp
\fI\%gearman_job_function_name()\fP return the name of the function that the
job was set to execute against.
.sp
\fI\%gearman_job_unique()\fP return the unique value that was used for \fI\%gearman_job_st\fP\&.
.sp
gearman_job_take_workload returns the \fI\%gearman_job_st\fP workload. The size of it can be determined with \fI\%gearman_job_workload_size()\fP\&.
\fI\%gearman_job_take_workload()\fP is the same as \fI\%gearman_job_workload()\fP with the exception that the result must be
\fIfree(3)\fP by the caller.
.sp
gearman_job_use_client returns a \fBgearman_client_st\fP configured from gearman_job_st. The gearman_client_st can be used to communicate client API commands to the server.
You do not, and should not, call \fBgearman_client_free()\fP on the gearman_client_st. It is cleaned up when job is cleaned up.
.SH RETURN VALUE
.sp
A value of \fBgearman_return_t\fP  is returned.  On success that value
will be :c:type::\fIGEARMAN_SUCCESS\fP\&.  Use \fBgearman_strerror()\fP to
translate this value to a printable string.
.SH HOME
.sp
To find out more information please check:
\fI\%http://gearman.info/\fP
.SH SEE ALSO
.sp
\fIgearmand(8)\fP \fIlibgearman(3)\fP
.SH AUTHOR
Data Differential http://www.datadifferential.com/
.SH COPYRIGHT
2011-2013, Data Differential, http://www.datadifferential.com/
.\" Generated by docutils manpage writer.
.
